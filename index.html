<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Robot simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Display robot model in 3D, animate movements and allow to export parts for manufacturing.">
<style>
body, html {
  margin: 0;
  height: 100%;
  overflow: hidden;
}

canvas {
  width: 100%;
  height: 100%;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const maxX            = 2;
const maxY            = 2;
const virusSectors    = 6;
const virusHeadWidth  = maxX * 0.4;
const virusLegWidth   = maxX * 0.6;
const virusHeadTop    = maxY * 0.15;
const virusHead       = maxY * 0.25;
const virusHeadBottom = maxY * 0.15;
const virusNeck       = maxY * 0.15;
const virusHip        = maxY * 0.1;
const virusLeg        = maxY * 0.12;

const genVirus = () => {
	const lines = [];
	const top = [maxX / 2, 0, maxX / 2];
	const neck = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom, maxX / 2];
	const pelvis = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom + virusNeck, maxX / 2];
	const angle = 2 * Math.PI / virusSectors;
	for (let i = 0; i < virusSectors; i++) {
		const headTop = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i)];
		const headTopNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1)),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1))];
		const headBottom = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i + angle / 2)];
		const headBottomNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1) + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1) + angle / 2)];
		const knee = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		const feet = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip + virusLeg,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		lines.push([top, headTop]);
		lines.push([headTop, headTopNext]);
		lines.push([headTop, headBottom]);
		lines.push([headBottom, headBottomNext]);
		lines.push([headTopNext, headBottom]);
		lines.push([headBottom, neck]);
		lines.push([neck, pelvis]);
		lines.push([pelvis, knee]);
		lines.push([knee, feet]);
	}
	return lines;
}

var vertexShaderSource = `#version 300 es
in vec4 a_position;

uniform mat4 u_matrix;

out float v_depth;

void main() {
  vec4 newPosition = u_matrix * a_position;
  gl_Position = newPosition;
  v_depth = newPosition.x * 0.5 + 0.5;
}
`;

var fragmentShaderSource = `#version 300 es
precision highp float;

in float v_depth;

out vec4 outColor;

void main() {
  outColor = vec4(v_depth, v_depth, v_depth, 1);
}
`;

const createShader = (gl, type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader;
  }
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

const createProgram = (gl, vertexShader, fragmentShader) => {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    return program;
  }
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

const degToRad = (d) => d * Math.PI / 180;

const resizeCanvasToDisplaySize = (canvas) => {
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl2");

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);
gl.useProgram(program);
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const matrixLocation = gl.getUniformLocation(program, "u_matrix");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [];
for (const line of genVirus()) {
    for (const point of line) {
        for (const coord of point) {
            positions.push(1 - coord);
        }
    }
}
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

const rotation = [degToRad(-25), degToRad(0), degToRad(0)];
const rotationSpeed = 0.6;

const multiply2Matrices = (a, b) => {
  const result = [];

  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
      a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
      a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
      a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  result[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  result[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  result[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  result[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  return result;
}

function multiplyMatrices() {
  let result = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    result = multiply2Matrices(result, arguments[i]);
  }
  return result;
}

const perspectiveMatrix = (fieldOfViewInRadians, aspectRatio, near, far) => {
  const f = 1.0 / Math.tan(fieldOfViewInRadians / 2);
  const rangeInv = 1 / (near - far);
  return [
    f / aspectRatio, 0,                          0,   0,
    0,               f,                          0,   0,
    0,               0,    (near + far) * rangeInv,  -1,
    0,               0,  near * far * rangeInv * 2,   0
  ];
}

const translateMatrix = (x, y, z) => [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  x, y, z, 1
];

const scaleMatrix = (w, h, d) => [
  w, 0, 0, 0,
  0, h, 0, 0,
  0, 0, d, 0,
  0, 0, 0, 1
];


const rotateXMatrix = (a) => [
  1, 0, 0, 0,
  0, Math.cos(a), -Math.sin(a), 0,
  0, Math.sin(a), Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateYMatrix = (a) => [
  Math.cos(a), 0, Math.sin(a), 0,
  0, 1, 0, 0,
  -Math.sin(a), 0, Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateZMatrix = (a) => [
  Math.cos(a), -Math.sin(a), 0, 0,
  Math.sin(a), Math.cos(a), 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
];

const drawScene = () => {
  resizeCanvasToDisplaySize(gl.canvas);

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  rotation[1] += rotationSpeed / 60.0;
  const aspectRatio = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const near = 0;
  const far = 2000;
  const fieldOfViewInRadians = degToRad(60);
  const translation = [0, 0, -3];
  const f = 1.0 / Math.tan(fieldOfViewInRadians / 2);
  const rangeInv = 1 / (near - far);
  const matrix = multiplyMatrices(
    perspectiveMatrix(fieldOfViewInRadians, aspectRatio, near, far),
    translateMatrix(0, 0, -3),
    rotateXMatrix(rotation[0]),
    rotateYMatrix(rotation[1]),
    rotateZMatrix(rotation[2]),
  );

  gl.uniformMatrix4fv(matrixLocation, false, matrix);
  gl.drawArrays(gl.LINES, 0, positions.length / 3);

  requestAnimationFrame(drawScene);
}

requestAnimationFrame(drawScene);
</script>
</body>
</html>
