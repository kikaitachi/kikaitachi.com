<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KIKAItachi</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Computer Aided Design (CAD) software for 3D printing and CNC machining.">
<link rel="canonical" href="https://kikaitachi.com/"/>
<link rel="icon" type="image/svg+xml" href="/logo.svg">
<style>
body, html {
  margin: 0;
  height: 100%;
  overflow: hidden;
}
#c {
  width: 100%;
  height: 100%;
}
#d {
  border: 1px solid silver;
  border-radius: 1rem;
  color: silver;
  padding: 0 0.5rem;
  position: fixed;
  right: 0.5rem;
  top: 0.5rem;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="d">Download STEP</div>
<script>
const maxX            = 2;
const maxY            = 2;
const virusSectors    = 6;
const virusHeadWidth  = maxX * 0.4;
const virusLegWidth   = maxX * 0.6;
const virusHeadTop    = maxY * 0.15;
const virusHead       = maxY * 0.25;
const virusHeadBottom = maxY * 0.15;
const virusNeck       = maxY * 0.15;
const virusHip        = maxY * 0.1;
const virusLeg        = maxY * 0.12;

const genVirus = () => {
	const lines = [];
	const top = [maxX / 2, 0, maxX / 2];
	const neck = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom, maxX / 2];
	const pelvis = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom + virusNeck, maxX / 2];
	const angle = 2 * Math.PI / virusSectors;
	for (let i = 0; i < virusSectors; i++) {
		const headTop = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i)];
		const headTopNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1)),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1))];
		const headBottom = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i + angle / 2)];
		const headBottomNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1) + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1) + angle / 2)];
		const knee = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		const feet = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip + virusLeg,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		lines.push([top, headTop]);
		lines.push([headTop, headTopNext]);
		lines.push([headTop, headBottom]);
		lines.push([headBottom, headBottomNext]);
		lines.push([headTopNext, headBottom]);
		lines.push([headBottom, neck]);
		lines.push([neck, pelvis]);
		lines.push([pelvis, knee]);
		lines.push([knee, feet]);
	}
	return lines;
}

var vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_matrix;

out vec3 v_normal;

void main() {
  gl_Position = u_matrix * a_position;
  v_normal = a_normal;
}
`;

var fragmentShaderSource = `#version 300 es
precision highp float;

in vec3 v_normal;

out vec4 outColor;

void main() {
  vec3 normal = normalize(v_normal) * 0.6 + 0.4;
  outColor = vec4(normal[0], normal[1], normal[2], 1);
}
`;

const createShader = (gl, type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader;
  }
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

const createProgram = (gl, vertexShader, fragmentShader) => {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    return program;
  }
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

const degToRad = (d) => d * Math.PI / 180;

const resizeCanvasToDisplaySize = (canvas) => {
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl2");

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);
gl.useProgram(program);
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const normalLocation = gl.getAttribLocation(program, "a_normal");
const matrixLocation = gl.getUniformLocation(program, "u_matrix");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [];
for (const line of genVirus()) {
    for (const point of line) {
        for (const coord of point) {
            positions.push(1 - coord);
        }
    }
}
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

const normalBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
gl.enableVertexAttribArray(normalLocation);
gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);

const near = 0.1;
const far = 2000;
const fieldOfViewInRadians = degToRad(60);
const rotation = [degToRad(-25), degToRad(0), degToRad(0)];
const rotationSpeed = 0.6;

const multiply2Matrices = (a, b) => {
  const result = [];

  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
      a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
      a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
      a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  result[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  result[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  result[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  result[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  return result;
}

const multiplyMatrices = (...arguments) => {
  let result = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    result = multiply2Matrices(result, arguments[i]);
  }
  return result;
}

const perspectiveMatrix = (fieldOfViewInRadians, aspectRatio, near, far) => {
  const f = 1.0 / Math.tan(fieldOfViewInRadians / 2);
  const rangeInv = 1 / (near - far);
  return [
    f / aspectRatio, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (near + far) * rangeInv, -1,
    0, 0, near * far * rangeInv * 2, 0
  ];
}

const translateMatrix = (x, y, z) => [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  x, y, z, 1
];

const scaleMatrix = (w, h, d) => [
  w, 0, 0, 0,
  0, h, 0, 0,
  0, 0, d, 0,
  0, 0, 0, 1
];


const rotateXMatrix = (a) => [
  1, 0, 0, 0,
  0, Math.cos(a), -Math.sin(a), 0,
  0, Math.sin(a), Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateYMatrix = (a) => [
  Math.cos(a), 0, Math.sin(a), 0,
  0, 1, 0, 0,
  -Math.sin(a), 0, Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateZMatrix = (a) => [
  Math.cos(a), -Math.sin(a), 0, 0,
  Math.sin(a), Math.cos(a), 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
];

let scale = far / 4;
let x = 0;
let y = 0;
let z = -(far - near) / 2;

let loading = true;

const drawScene = () => {
  resizeCanvasToDisplaySize(gl.canvas);

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.CULL_FACE);

  //rotation[1] += rotationSpeed / 60.0;
  const aspectRatio = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const matrix = multiplyMatrices(
    perspectiveMatrix(fieldOfViewInRadians, aspectRatio, near, far),
    translateMatrix(x, y, z),
    rotateXMatrix(rotation[0]),
    rotateYMatrix(rotation[1]),
    rotateZMatrix(rotation[2]),
    scaleMatrix(scale, scale, scale),
  );

  gl.uniformMatrix4fv(matrixLocation, false, matrix);
  if (loading) {
    gl.drawArrays(gl.LINES, 0, positions.length / 3);
  } else {
    gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);
  }

  requestAnimationFrame(drawScene);
}

requestAnimationFrame(drawScene);

function visualize(openCascade, shape) {
  let geometries = []
  const ExpFace = new openCascade.TopExp_Explorer_1();
  for (ExpFace.Init(shape, openCascade.TopAbs_ShapeEnum.TopAbs_FACE, openCascade.TopAbs_ShapeEnum.TopAbs_SHAPE); ExpFace.More(); ExpFace.Next()) {
    const myShape = ExpFace.Current();
    const myFace = openCascade.TopoDS.Face_1(myShape);
    let inc;
    try {
      //in case some of the faces can not been visualized
      inc = new openCascade.BRepMesh_IncrementalMesh_2(myFace, 0.025, false, 0.125, false);
    } catch (e) {
      console.error(`failed to build incremental mesh: ${e}`);
      continue;
    }

    const aLocation = new openCascade.TopLoc_Location_1();
    const myT = openCascade.BRep_Tool.Triangulation(myFace, aLocation, 0 /* == Poly_MeshPurpose_NONE */);
    if (myT.IsNull()) {
      continue;
    }

    const pc = new openCascade.Poly_Connect_2(myT);
    const triangulation = myT.get();

    let vertices = new Float32Array(triangulation.NbNodes() * 3);

    // write vertex buffer
    for (let i = 1; i <= triangulation.NbNodes(); i++) {
      const t1 = aLocation.Transformation();
      const p = triangulation.Node(i);
      const p1 = p.Transformed(t1);
      vertices[3 * (i - 1)] = p1.X();
      vertices[3 * (i - 1) + 1] = p1.Y();
      vertices[3 * (i - 1) + 2] = p1.Z();
      p.delete();
      t1.delete();
      p1.delete();
    }

    // write normal buffer
    const myNormal = new openCascade.TColgp_Array1OfDir_2(1, triangulation.NbNodes());
    openCascade.StdPrs_ToolTriangulatedShape.Normal(myFace, pc, myNormal);

    let normals = new Float32Array(myNormal.Length() * 3);
    for (let i = myNormal.Lower(); i <= myNormal.Upper(); i++) {
      const t1 = aLocation.Transformation();
      const d1 = myNormal.Value(i);
      const d = d1.Transformed(t1);

      normals[3 * (i - 1)] = d.X();
      normals[3 * (i - 1) + 1] = d.Y();
      normals[3 * (i - 1) + 2] = d.Z();

      t1.delete();
      d1.delete();
      d.delete();
    }

    myNormal.delete();

    // write triangle buffer
    const orient = myFace.Orientation_1();
    const triangles = myT.get().Triangles();
    let indices;
    let triLength = triangles.Length() * 3;
    if (triLength > 65535)
      indices = new Uint32Array(triLength);
    else
      indices = new Uint16Array(triLength);

    for (let nt = 1; nt <= myT.get().NbTriangles(); nt++) {
      const t = triangles.Value(nt);
      let n1 = t.Value(1);
      let n2 = t.Value(2);
      let n3 = t.Value(3);
      if (orient !== openCascade.TopAbs_Orientation.TopAbs_FORWARD) {
        let tmp = n1;
        n1 = n2;
        n2 = tmp;
      }

      indices[3 * (nt - 1)] = n1 - 1;
      indices[3 * (nt - 1) + 1] = n2 - 1;
      indices[3 * (nt - 1) + 2] = n3 - 1;
      t.delete();
    }
    triangles.delete();

    geometries.push({
      vertices: vertices,
      normals: normals,
      indices: indices,
    });

    pc.delete();
    aLocation.delete();
    myT.delete();
    inc.delete();
    myFace.delete();
    myShape.delete();
  }
  ExpFace.delete();
  return geometries;
}

const shapeToSTEP = (openCascade, shape, fileName) => {
  const writer = new openCascade.STEPControl_Writer_1();
  writer.Transfer(shape, openCascade.STEPControl_StepModelType.STEPControl_AsIs, true, new openCascade.Message_ProgressRange_1());
  writer.Write(fileName);
  const result = openCascade.FS.readFile("/" + fileName, { encoding:"utf8" });
  openCascade.FS.unlink("/" + fileName);
  return result;
}

const addShape = (oc, shape) => {
  positions.length = 0;
  loading = false;
  const normals = [];
  visualize(oc, shape).forEach(tesselated => {
    for (let i = 0; i < tesselated.indices.length / 3; i++) {
      positions.push(
        tesselated.vertices[tesselated.indices[i * 3] * 3],
        tesselated.vertices[tesselated.indices[i * 3] * 3 + 1],
        tesselated.vertices[tesselated.indices[i * 3] * 3 + 2]
      );
      normals.push(
        tesselated.normals[tesselated.indices[i * 3] * 3],
        tesselated.normals[tesselated.indices[i * 3] * 3 + 1],
        tesselated.normals[tesselated.indices[i * 3] * 3 + 2]
      );
      positions.push(
        tesselated.vertices[tesselated.indices[i * 3 + 1] * 3],
        tesselated.vertices[tesselated.indices[i * 3 + 1] * 3 + 1],
        tesselated.vertices[tesselated.indices[i * 3 + 1] * 3 + 2]
      );
      normals.push(
        tesselated.normals[tesselated.indices[i * 3 + 1] * 3],
        tesselated.normals[tesselated.indices[i * 3 + 1] * 3 + 1],
        tesselated.normals[tesselated.indices[i * 3 + 1] * 3 + 2]
      );
      positions.push(
        tesselated.vertices[tesselated.indices[i * 3 + 2] * 3],
        tesselated.vertices[tesselated.indices[i * 3 + 2] * 3 + 1],
        tesselated.vertices[tesselated.indices[i * 3 + 2] * 3 + 2]
      );
      normals.push(
        tesselated.normals[tesselated.indices[i * 3 + 2] * 3],
        tesselated.normals[tesselated.indices[i * 3 + 2] * 3 + 1],
        tesselated.normals[tesselated.indices[i * 3 + 2] * 3 + 2]
      );
    }
  });
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
}

// https://cdn.jsdelivr.net/npm/opencascade.js@2.0.0-beta.94e2944
import("/opencascade.full.js")
  .then((module) => {
    module.default().then((oc) => {
      let current_shape = null;

      const difference = (...arguments) => {
        let result = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          let intermediate = new oc.BRepAlgoAPI_Cut_3(result, arguments[i], new oc.Message_ProgressRange_1());
          intermediate.Build(new oc.Message_ProgressRange_1());
          result = intermediate.Shape();
        }
        return current_shape = result;
      }
      const intersection = (...arguments) => {
        let result = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          let intermediate = new oc.BRepAlgoAPI_Common_3(result, arguments[i], new oc.Message_ProgressRange_1());
          intermediate.Build(new oc.Message_ProgressRange_1());
          result = intermediate.Shape();
        }
        return current_shape = result;
      }
      const union = (...arguments) => {
        let result = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          let intermediate = new oc.BRepAlgoAPI_Fuse_3(result, arguments[i], new oc.Message_ProgressRange_1());
          intermediate.Build(new oc.Message_ProgressRange_1());
          result = intermediate.Shape();
        }
        return current_shape = result;
      }
      const box = (params) => {
        const result = new oc.BRepPrimAPI_MakeBox_2(
          params.width,
          params.height,
          params.depth
        ).Shape();
        return current_shape = result;
      };
      const cone = (params) => {
        const result = new oc.BRepPrimAPI_MakeCone_1(
          params.radiusTop,
          params.radiusBottom,
          params.height
        ).Shape();
        return current_shape = result;
      };
      const sphere = (params) => {
        const result = new oc.BRepPrimAPI_MakeSphere_1(
          params.radius
        ).Shape();
        return current_shape = result;
      }

      document.getElementById('d').addEventListener('click', () => {
        if (current_shape != null) {
          const el = document.createElement('a');
          const fileName = 'part.step';
          el.setAttribute('download', fileName);
          const href = URL.createObjectURL(new Blob([shapeToSTEP(oc, current_shape, fileName)], {
            type: "application/STEP",
          }));
          el.href = href;
          el.setAttribute('target', '_blank');
          el.click();
          URL.revokeObjectURL(href);
        }
      });

      const processFiles = (item) => {
        console.log(`Name: ${item.name}, path: ${item.fullPath}`);
        if (item.isDirectory) {
          item.createReader().readEntries((entries) => {
            entries.forEach((entry) => {
              processFiles(entry);
            });
          });
        } else {
          item.file((file) => {
            const reader = new FileReader();
            reader.onload = () => {
              eval('(function() {' + reader.result + '})();addShape(oc, current_shape);');
            };
            reader.readAsText(file);
          });
        }
      };
      canvas.addEventListener("dragover", (event) => {
        event.preventDefault();
      }, false);
      canvas.addEventListener("drop", (event) => {
        const items = event.dataTransfer.items;
        event.preventDefault();
        for (let i = 0; i < items.length; i++) {
          let item = items[i].webkitGetAsEntry();
          if (item) {
            processFiles(item);
          }
        }
      }, false);
    });
  });

canvas.addEventListener('wheel', (event) => {
  event.preventDefault();
  scale += event.deltaY * -0.2;
});

let rotating = false;
let moving = false;
let startX, startY;
document.addEventListener('contextmenu', (event) => {
  event.preventDefault();
}, false);
canvas.addEventListener('mousedown', (event) => {
  event.preventDefault();
  if (event.buttons == 1) {
    rotating = true;
  }
  if (event.buttons == 2) {
    moving = true;
  }
  startX = event.clientX;
  startY = event.clientY;
}, false);
canvas.addEventListener('mouseup', (event) => {
  event.preventDefault();
  rotating = false;
  moving = false;
}, false);
canvas.addEventListener('mousemove', (event) => {
  event.preventDefault();
  if (moving) {
    x += event.clientX - startX;
    y -= event.clientY - startY;
  }
  if (rotating) {
    rotation[1] -= degToRad(event.clientX - startX);
    rotation[0] -= degToRad(event.clientY - startY);
  }
  startX = event.clientX;
  startY = event.clientY;
}, false);
</script>
</body>
</html>
