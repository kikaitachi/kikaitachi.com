<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KIKAItachi</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Computer Aided Design (CAD) software for 3D printing and CNC machining.">
<style>
body, html {
  margin: 0;
  height: 100%;
  overflow: hidden;
}

canvas {
  width: 100%;
  height: 100%;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const maxX            = 2;
const maxY            = 2;
const virusSectors    = 6;
const virusHeadWidth  = maxX * 0.4;
const virusLegWidth   = maxX * 0.6;
const virusHeadTop    = maxY * 0.15;
const virusHead       = maxY * 0.25;
const virusHeadBottom = maxY * 0.15;
const virusNeck       = maxY * 0.15;
const virusHip        = maxY * 0.1;
const virusLeg        = maxY * 0.12;

const genVirus = () => {
	const lines = [];
	const top = [maxX / 2, 0, maxX / 2];
	const neck = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom, maxX / 2];
	const pelvis = [maxX / 2, virusHeadTop + virusHead + virusHeadBottom + virusNeck, maxX / 2];
	const angle = 2 * Math.PI / virusSectors;
	for (let i = 0; i < virusSectors; i++) {
		const headTop = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i)];
		const headTopNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1)),
      virusHeadTop,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1))];
		const headBottom = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * i + angle / 2)];
		const headBottomNext = [maxX / 2 + virusHeadWidth / 2 * Math.sin(angle * (i + 1) + angle / 2),
      virusHeadTop + virusHead,
      maxX / 2 + virusHeadWidth / 2 * Math.cos(angle * (i + 1) + angle / 2)];
		const knee = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		const feet = [maxX / 2 + virusLegWidth / 2 * Math.sin(angle * i + angle / 2),
      virusHeadTop + virusHead + virusHeadBottom + virusNeck + virusHip + virusLeg,
      maxX / 2 + virusLegWidth / 2 * Math.cos(angle * i + angle / 2)];
		lines.push([top, headTop]);
		lines.push([headTop, headTopNext]);
		lines.push([headTop, headBottom]);
		lines.push([headBottom, headBottomNext]);
		lines.push([headTopNext, headBottom]);
		lines.push([headBottom, neck]);
		lines.push([neck, pelvis]);
		lines.push([pelvis, knee]);
		lines.push([knee, feet]);
	}
	return lines;
}

var vertexShaderSource = `#version 300 es
in vec4 a_position;

uniform mat4 u_matrix;

out float v_depth;

void main() {
  vec4 newPosition = u_matrix * a_position;
  gl_Position = newPosition;
  v_depth = newPosition.x * 0.5 + 0.5;
}
`;

var fragmentShaderSource = `#version 300 es
precision highp float;

in float v_depth;

out vec4 outColor;

void main() {
  outColor = vec4(v_depth, v_depth, v_depth, 1);
}
`;

const createShader = (gl, type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader;
  }
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

const createProgram = (gl, vertexShader, fragmentShader) => {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    return program;
  }
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

const degToRad = (d) => d * Math.PI / 180;

const resizeCanvasToDisplaySize = (canvas) => {
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl2");

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);
gl.useProgram(program);
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const matrixLocation = gl.getUniformLocation(program, "u_matrix");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [];
for (const line of genVirus()) {
    for (const point of line) {
        for (const coord of point) {
            positions.push(1 - coord);
        }
    }
}
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

const near = 0;
const far = 2000;
const fieldOfViewInRadians = degToRad(60);
const rotation = [degToRad(-25), degToRad(0), degToRad(0)];
const rotationSpeed = 0.6;

const multiply2Matrices = (a, b) => {
  const result = [];

  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
      a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
      a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
      a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  result[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  result[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  result[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  result[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  result[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  result[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  result[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  return result;
}

function multiplyMatrices() {
  let result = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    result = multiply2Matrices(result, arguments[i]);
  }
  return result;
}

const perspectiveMatrix = (fieldOfViewInRadians, aspectRatio, near, far) => {
  const f = 1.0 / Math.tan(fieldOfViewInRadians / 2);
  const rangeInv = 1 / (near - far);
  return [
    f / aspectRatio, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (near + far) * rangeInv, -1,
    0, 0, near * far * rangeInv * 2, 0
  ];
}

const translateMatrix = (x, y, z) => [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  x, y, z, 1
];

const scaleMatrix = (w, h, d) => [
  w, 0, 0, 0,
  0, h, 0, 0,
  0, 0, d, 0,
  0, 0, 0, 1
];


const rotateXMatrix = (a) => [
  1, 0, 0, 0,
  0, Math.cos(a), -Math.sin(a), 0,
  0, Math.sin(a), Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateYMatrix = (a) => [
  Math.cos(a), 0, Math.sin(a), 0,
  0, 1, 0, 0,
  -Math.sin(a), 0, Math.cos(a), 0,
  0, 0, 0, 1
];

const rotateZMatrix = (a) => [
  Math.cos(a), -Math.sin(a), 0, 0,
  Math.sin(a), Math.cos(a), 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
];

const drawScene = () => {
  resizeCanvasToDisplaySize(gl.canvas);

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  rotation[1] += rotationSpeed / 60.0;
  const aspectRatio = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const matrix = multiplyMatrices(
    perspectiveMatrix(fieldOfViewInRadians, aspectRatio, near, far),
    translateMatrix(0, 0, -3),
    rotateXMatrix(rotation[0]),
    rotateYMatrix(rotation[1]),
    rotateZMatrix(rotation[2]),
  );

  gl.uniformMatrix4fv(matrixLocation, false, matrix);
  gl.drawArrays(gl.LINES, 0, positions.length / 3);

  requestAnimationFrame(drawScene);
}

requestAnimationFrame(drawScene);

const openCascadeHelper = {
  setOpenCascade(openCascade) {
    this.openCascade = openCascade;
  },
  tessellate(shape) {
    const facelist = [];
    new this.openCascade.BRepMesh_IncrementalMesh_2(shape, 0.1, false, 0.5, false);
    const ExpFace = new this.openCascade.TopExp_Explorer_1();
    for (ExpFace.Init(shape, this.openCascade.TopAbs_ShapeEnum.TopAbs_FACE, this.openCascade.TopAbs_ShapeEnum.TopAbs_SHAPE); ExpFace.More(); ExpFace.Next()) {
      const myFace = this.openCascade.TopoDS.Face_1(ExpFace.Current());
      const aLocation = new this.openCascade.TopLoc_Location_1();
      const myT = this.openCascade.BRep_Tool.Triangulation(myFace, aLocation, 0 /* == Poly_MeshPurpose_NONE */);
      if (myT.IsNull()) {
        continue;
      }

      const this_face = {
        vertex_coord: [],
        normal_coord: [],
        tri_indexes: [],
        number_of_triangles: 0,
      };

      const pc = new this.openCascade.Poly_Connect_2(myT);
      const triangulation = myT.get();

      // write vertex buffer
      this_face.vertex_coord = new Array(triangulation.NbNodes() * 3);
      for (let i = 1; i <= triangulation.NbNodes(); i++) {
        const p = triangulation.Node(i).Transformed(aLocation.Transformation());
        this_face.vertex_coord[((i - 1) * 3) + 0] = p.X();
        this_face.vertex_coord[((i - 1) * 3) + 1] = p.Y();
        this_face.vertex_coord[((i - 1) * 3) + 2] = p.Z();
      }

      // write normal buffer
      const myNormal = new this.openCascade.TColgp_Array1OfDir_2(1, triangulation.NbNodes());
      this.openCascade.StdPrs_ToolTriangulatedShape.Normal(myFace, pc, myNormal);
      this_face.normal_coord = new Array(myNormal.Length() * 3);
      for (let i = myNormal.Lower(); i <= myNormal.Upper(); i++) {
        const d = myNormal.Value(i).Transformed(aLocation.Transformation());
        this_face.normal_coord[((i - 1) * 3) + 0] = d.X();
        this_face.normal_coord[((i - 1) * 3) + 1] = d.Y();
        this_face.normal_coord[((i - 1) * 3) + 2] = d.Z();
      }

      // write triangle buffer
      const orient = myFace.Orientation_1();
      const triangles = myT.get().Triangles();
      this_face.tri_indexes = new Array(triangles.Length() * 3);
      let validFaceTriCount = 0;
      for (let nt = 1; nt <= myT.get().NbTriangles(); nt++) {
        const t = triangles.Value(nt);
        let n1 = t.Value(1);
        let n2 = t.Value(2);
        let n3 = t.Value(3);
        if (orient !== this.openCascade.TopAbs_Orientation.TopAbs_FORWARD) {
          let tmp = n1;
          n1 = n2;
          n2 = tmp;
        }
        this_face.tri_indexes[(validFaceTriCount * 3) + 0] = n1;
        this_face.tri_indexes[(validFaceTriCount * 3) + 1] = n2;
        this_face.tri_indexes[(validFaceTriCount * 3) + 2] = n3;
        validFaceTriCount++;
      }
      this_face.number_of_triangles = validFaceTriCount;
      facelist.push(this_face);
    }
    return facelist;
  }
};

// https://cdn.jsdelivr.net/npm/opencascade.js@2.0.0-beta.54fa06a
import("/opencascade.full.js")
  .then((module) => {
    module.default().then((oc) => {
      openCascadeHelper.setOpenCascade(oc);
      const sphere = new oc.BRepPrimAPI_MakeSphere_1(1).Shape();
      const tesselated = openCascadeHelper.tessellate(sphere);
      console.log("Tesselated sphere:" + tesselated);
    });
  });
</script>
</body>
</html>
